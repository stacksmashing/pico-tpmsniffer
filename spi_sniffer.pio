; program to sniff spi communication directly on the tpm chip
; SELECT pin has to be active low when sampling
; sampling happens on rising clock edge
; phase 0

.program spi_sniffer

; IN pin 0 DO 
; IN pin 1 DI
; IN pin 2 CLK
; IN pin 3 SELECT / JMP_PIN

entry:
    wait 1 pin 3
.wrap_target
wait_select:
	wait 0 pin 3			; wait for SCK to go low
clock_cycle:
	wait 0 pin 2			; wait for clock low
	wait 1 pin 2			; wait for clock high (sample @ rising edge)
	jmp pin wait_select     ; make sure SeLECT is still low before sampling bit
sample_bits:
	in pins, 2			    ; sample data bit from DO and DI 
.wrap 

% c-sdk {
static inline void spi_sniffer_program_init(PIO pio, uint sm, uint offset, uint base_pin, uint jmp_pin) {
    pio_sm_config c = spi_sniffer_program_get_default_config(offset);
    
    // initialize 4 input pins DO, DI, CLK, SELECT
    for(int i=0; i < 4; i++) {
        pio_gpio_init(pio, base_pin + i);
    }
    //gpio_pull_down(base_pin + 3); // set inner pull up resistor for SELET pin
    
    // initialize JUMP PIN (Here this is actually not necessary)
    // pio_gpio_init(pio, jmp_pin);

    // Set all pins to input (false = input)
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 4, false);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_jmp_pin(&c, jmp_pin);

    // set autopush at threshold 16 bit
    // we are reading DO and DI at the same time
    sm_config_set_in_shift (&c, false, true, 16);

    // Chain FIFOs together as we will *only* receive.
    // This will ensure we will not block.
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    // run at max clockrate
    float div = 1.f ; //(float)clock_get_hz(clk_sys) / 135000000.0;
    sm_config_set_clkdiv(&c, div);
    
    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}
